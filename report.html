<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Functional Shoulder Screening - A4 Report</title>
    <script src="https://cdn.plot.ly/plotly-2.27.1.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Avenir:wght@400&family=Futura:wght@400&display=swap">
    <style>
        :root {
            --app-primary-color: #285484;
            --app-secondary-color: rgb(112, 188, 252);
            --light-gray: #f8f9fa;
            --box-background-color: #f0f2f5;
            --medium-gray: #dee2e6;
            --dark-gray: #495057;
            --text-color: #212529;
            --white: #ffffff;
            --border-radius: 4px;
            --subtle-shadow: 0 1px 3px rgba(0,0,0,0.07);
            --left-line-color: #ff7f0e; /* Orange */
            --right-line-color: #1f77b4; /* Blue */
            --norm-poor-bg: rgba(252, 165, 165, 0.5);
            --norm-average-bg: rgba(252, 211, 77, 0.5);
            --norm-good-bg: rgba(167, 243, 208, 0.5);
            --norm-excellent-bg: rgba(52, 211, 153, 0.5);
            --base-font-size: 16px;
            --normal-font-weight: 400;
            --semibold-font-weight: 400;
            --bold-font-weight: 700;
            --scale-factor: 0.7; /* Global scaling for A4 */
        }
        body {
            font-family: 'Avenir', sans-serif;
            background-color: var(--white); /* Changed for printing */
            color: var(--text-color);
            margin: 0;
            padding: 0;
            line-height: 1.6;
            font-size: calc(var(--base-font-size) * var(--scale-factor));
             -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
        }
        .page {
            width: 210mm;
            min-height: 297mm;
            margin: 0 auto;
            overflow: hidden;
        }
        .app-main-content {
            padding: 15mm 20mm !important; /* Adjusted top padding */
            height: auto !important;
            overflow: visible !important;
            box-shadow: none !important;
            border: none !important;
        }
        .content-container {
            max-width: 100% !important;
            margin: 0 auto;
        }
        .info-box {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px 30px;
            background-color: var(--white);
            border: 1px solid var(--medium-gray);
            padding: 12px 20px;
            margin-bottom: 25px;
            border-radius: var(--border-radius);
            font-size: calc(13px * var(--scale-factor));
        }
        .info-box div {
            display: flex;
            justify-content: space-between;
            padding-bottom: 4px;
        }
        .info-box strong {
            color: var(--app-primary-color);
            margin-right: 10px;
            font-weight: var(--semibold-font-weight);
        }
        h1 {
            text-align: center;
            font-size: calc(2.0rem * var(--scale-factor));
            margin-top: 0;
            margin-bottom: 1.5em; /* Increased bottom margin */
            color: var(--app-primary-color);
        }
        h3.position-title, h3.normative-title {
            font-size: calc(1.15rem * var(--scale-factor));
            color: var(--app-primary-color);
            margin-bottom: 0.3em;
            text-align: center;
        }
        .position-row {
            display: flex !important;
            flex-wrap: nowrap !important;
            gap: 20px !important;
            margin-bottom: 20px;
            align-items: stretch;
            page-break-inside: avoid !important;
            width: 100% !important;
            box-sizing: border-box !important;
        }
        .graph-column {
            min-width: 0 !important;
            display: flex;
            flex-direction: column;
            page-break-inside: avoid !important;
        }
        .position-row .graph-column:nth-child(1) {
            flex: 11 !important; /* 55% ratio */
        }
        .position-row .graph-column:nth-child(2) {
            flex: 9 !important; /* 45% ratio */
        }
        .position-box, .normative-box {
            border: none !important;
            padding: 10px 15px !important;
            border-radius: var(--border-radius);
            background-color: var(--box-background-color) !important;
            box-shadow: none !important;
            display: flex !important;
            flex-direction: column !important;
            height: 250px !important; /* Increased height for labels */
            min-height: 250px !important;
            position: relative;
            overflow: hidden !important;
            width: 100% !important;
            box-sizing: border-box !important;
             -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
        }
        .js-plotly-plot {
            flex-grow: 1 !important;
            position: relative;
            z-index: 1;
            width: 100% !important;
            height: 100% !important;
        }
        .plotly .modebar { display: none !important; }

        @media print {
            body {
                background-color: var(--white);
            }
            .page {
                box-shadow: none !important;
                border: none !important;
                margin: 0;
                padding: 0;
            }
        }
    </style>
</head>
<body>
    <div class="page">
        <main class="app-main-content">
            <div class="content-container">
                 <h1>Functional Shoulder Screening</h1>
                 <div class="info-box">
                    <div><strong>NAME:</strong> <span id="p-name"></span></div>
                    <div><strong>DATE:</strong> <span id="p-date"></span></div>
                    <div><strong>SPORT:</strong> <span id="p-sport"></span></div>
                    <div><strong>CREATED BY:</strong> <span id="p-createdBy"></span></div>
                </div>
                <div id="report-content">
                    <div class="position-row">
                        <div class="graph-column">
                            <div id="position-box-I" class="position-box">
                                <h3 class="position-title">Position I - Asymmetry</h3>
                                <div id="bar-chart-I" class="js-plotly-plot"></div>
                            </div>
                        </div>
                        <div class="graph-column">
                            <div id="normative-chart-container-I" class="normative-box">
                                <h3 class="normative-title">Position I - Normative</h3>
                                <div id="normative-chart-I" class="js-plotly-plot"></div>
                            </div>
                        </div>
                    </div>
                    <div class="position-row">
                        <div class="graph-column">
                            <div id="position-box-Y" class="position-box">
                                <h3 class="position-title">Position Y - Asymmetry</h3>
                                <div id="bar-chart-Y" class="js-plotly-plot"></div>
                            </div>
                        </div>
                        <div class="graph-column">
                            <div id="normative-chart-container-Y" class="normative-box">
                                <h3 class="normative-title">Position Y - Normative</h3>
                                <div id="normative-chart-Y" class="js-plotly-plot"></div>
                            </div>
                        </div>
                    </div>
                    <div class="position-row">
                        <div class="graph-column">
                            <div id="position-box-T" class="position-box">
                                <h3 class="position-title">Position T - Asymmetry</h3>
                                <div id="bar-chart-T" class="js-plotly-plot"></div>
                            </div>
                        </div>
                        <div class="graph-column">
                            <div id="normative-chart-container-T" class="normative-box">
                                <h3 class="normative-title">Position T - Normative</h3>
                                <div id="normative-chart-T" class="js-plotly-plot"></div>
                            </div>
                        </div>
                    </div>
                    <!-- Hidden inputs to hold the data -->
                    <div id="input-section-container" style="display:none;">
                        <input id="non-injured-max-force-i"><input id="non-injured-rfd-i"><input id="injured-max-force-i"><input id="injured-rfd-i">
                        <input id="non-injured-max-force-y"><input id="non-injured-rfd-y"><input id="injured-max-force-y"><input id="injured-rfd-y">
                        <input id="non-injured-max-force-t"><input id="non-injured-rfd-t"><input id="injured-max-force-t"><input id="injured-rfd-t">
                    </div>
                </div>
            </div>
        </main>
    </div>

<script>
// --- START: Global Variables & Config ---
const plotlyConfig = { responsive: true, displaylogo: false, modeBarButtonsToRemove: ['sendDataToCloud', 'lasso2d', 'select2d', 'autoScale2d', 'hoverClosestCartesian', 'hoverCompareCartesian', 'toggleSpikelines'] };
const globalScaleFactor = 0.7;

// These will be populated from localStorage
let patientData = {};
let screeningData = {};

const normativeThresholds = {
    I: { poor_max: 1.47, average_mid: 1.65, good_min: 1.85, excellent_min: 2.1 },
    Y: { poor_max: 1.25, average_mid: 1.4, good_min: 1.6, excellent_min: 1.76 },
    T: { poor_max: 1.15, average_mid: 1.25, good_min: 1.4, excellent_min: 1.58 }
};
const percentileZones = { poor: 30, average: 70, good: 90, excellent: 100 };
const percentileMidpoint = 50;
const normZoneColors = {
    poor: getComputedStyle(document.documentElement).getPropertyValue('--norm-poor-bg').trim(),
    average: getComputedStyle(document.documentElement).getPropertyValue('--norm-average-bg').trim(),
    good: getComputedStyle(document.documentElement).getPropertyValue('--norm-good-bg').trim(),
    excellent: getComputedStyle(document.documentElement).getPropertyValue('--norm-excellent-bg').trim()
};
const normativeLabels = { poor: 'Poor', average: 'Average', good: 'Good', excellent: 'Excellent' };

const inputFieldMap = {
    'I': { nonInjured: [document.getElementById('non-injured-max-force-i'), document.getElementById('non-injured-rfd-i')], injured: [document.getElementById('injured-max-force-i'), document.getElementById('injured-rfd-i')] },
    'Y': { nonInjured: [document.getElementById('non-injured-max-force-y'), document.getElementById('non-injured-rfd-y')], injured: [document.getElementById('injured-max-force-y'), document.getElementById('injured-rfd-y')] },
    'T': { nonInjured: [document.getElementById('non-injured-max-force-t'), document.getElementById('non-injured-rfd-t')], injured: [document.getElementById('injured-max-force-t'), document.getElementById('injured-rfd-t')] }
};

const asymmetryChartDivs = ['bar-chart-I', 'bar-chart-Y', 'bar-chart-T'];
const normativeChartDivs = ['normative-chart-I', 'normative-chart-Y', 'normative-chart-T'];

// --- START: Data Loading and Population ---

function loadAndPopulateData() {
    // --- Load Patient Data ---
    const storedPatientData = localStorage.getItem('shoulderScreeningPatientData');
    if (storedPatientData) {
        patientData = JSON.parse(storedPatientData);
    } else {
        // No data in localStorage, initialize with empty values
        patientData = {
            name: '',
            date: '',
            sport: '',
            createdBy: '',
            injuredSide: 'Right', // Default side if none is provided
            bodyweight: ''
        };
    }

    // --- Load Screening Data ---
    const storedScreeningData = localStorage.getItem('shoulderScreeningTestData');
     if (storedScreeningData) {
        screeningData = JSON.parse(storedScreeningData);
    } else {
        // No data in localStorage, initialize as empty
        screeningData = {};
    }

    populateInfoBox(patientData);
    populateInputFields(screeningData);
}

function populateInfoBox(data) {
    document.getElementById('p-name').textContent = data.name || '';
    document.getElementById('p-date').textContent = data.date || '';
    document.getElementById('p-sport').textContent = data.sport || '';
    document.getElementById('p-createdBy').textContent = data.createdBy || '';
}

function populateInputFields(data) {
    ['I', 'Y', 'T'].forEach(pos => {
        if (data[pos]) {
            inputFieldMap[pos].nonInjured[0].value = data[pos].nonInjuredMaxForce || '';
            inputFieldMap[pos].nonInjured[1].value = data[pos].nonInjuredRfd || '';
            inputFieldMap[pos].injured[0].value = data[pos].injuredMaxForce || '';
            inputFieldMap[pos].injured[1].value = data[pos].injuredRfd || '';
        }
    });
}

// --- START: Graphing and Calculation Logic (largely unchanged) ---

function hexToRgba(hex, alpha) { hex = hex.replace('#', ''); const r = parseInt(hex.substring(0, 2), 16); const g = parseInt(hex.substring(2, 4), 16); const b = parseInt(hex.substring(4, 6), 16); return `rgba(${r}, ${g}, ${b}, ${alpha})`; }

function processInputAndCalculate(position) { const inputs = inputFieldMap[position]; if (!inputs) return null; const nonInjuredMaxForceVal = inputs.nonInjured[0].value; const nonInjuredRfdVal = inputs.nonInjured[1].value; const injuredMaxForceVal = inputs.injured[0].value; const injuredRfdVal = inputs.injured[1].value; if (nonInjuredMaxForceVal === '' && nonInjuredRfdVal === '' && injuredMaxForceVal === '' && injuredRfdVal === '') return null; const nonInjuredMaxForce = parseFloat(nonInjuredMaxForceVal) || 0; const nonInjuredRfd = parseFloat(nonInjuredRfdVal) || 0; const injuredMaxForce = parseFloat(injuredMaxForceVal) || 0; const injuredRfd = parseFloat(injuredRfdVal) || 0; const selectedInjuredSide = patientData.injuredSide || 'Left'; let leftData = {}; let rightData = {}; if (selectedInjuredSide === 'Left') { leftData = { max_force: injuredMaxForce, rfd: injuredRfd }; rightData = { max_force: nonInjuredMaxForce, rfd: nonInjuredRfd }; } else { leftData = { max_force: nonInjuredMaxForce, rfd: nonInjuredRfd }; rightData = { max_force: injuredMaxForce, rfd: injuredRfd }; } return { left: leftData, right: rightData }; }

function createAsymmetryChart(positionData, injuredSide, posLabel) { if (!positionData?.left || !positionData?.right) return [{}, false]; const leftDataRaw = positionData.left; const rightDataRaw = positionData.right; const leftPctMaxAt100ms = leftDataRaw.max_force !== 0 ? (leftDataRaw.rfd * 0.1 / leftDataRaw.max_force) * 100 : 0; const rightPctMaxAt100ms = rightDataRaw.max_force !== 0 ? (rightDataRaw.rfd * 0.1 / rightDataRaw.max_force) * 100 : 0; const leftData = [leftDataRaw.max_force, leftDataRaw.rfd, leftPctMaxAt100ms]; const rightData = [rightDataRaw.max_force, rightDataRaw.rfd, rightPctMaxAt100ms]; const baseData = injuredSide === 'Right' ? leftData : rightData; const metricNames = [ 'Max Force (N)', 'RFD@100ms (Ns⁻¹)', '%Max@100ms (%)' ]; const barDataRatios = {}; const leftTextsAbsolute = []; const rightTextsAbsolute = []; metricNames.forEach((metricName, index) => { let leftValue = leftData[index]; let rightValue = rightData[index]; let baseValue = baseData[index]; const leftRatio = baseValue !== 0 ? (leftValue / baseValue) * 100 : (leftValue === 0 ? 100 : Infinity); const rightRatio = baseValue !== 0 ? (rightValue / baseValue) * 100 : (rightValue === 0 ? 100 : Infinity); barDataRatios[metricName] = [rightRatio, leftRatio]; const decimals = metricName.includes('%Max@100ms') ? 1 : 0; leftTextsAbsolute.push(leftValue.toFixed(decimals)); rightTextsAbsolute.push(rightValue.toFixed(decimals)); }); const plotX = metricNames; const plotYLeft = plotX.map(name => barDataRatios[name][1]); const plotYRight = plotX.map(name => barDataRatios[name][0]); const leftColorHex = getComputedStyle(document.documentElement).getPropertyValue('--left-line-color').trim(); const rightColorHex = getComputedStyle(document.documentElement).getPropertyValue('--right-line-color').trim(); const leftColorRgba = hexToRgba(leftColorHex, 0.8); const rightColorRgba = hexToRgba(rightColorHex, 0.8); const thresholdLineColor = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim(); const darkGrayColor = getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim(); const validRatios = plotYLeft.concat(plotYRight).filter(isFinite); const maxYValue = validRatios.length > 0 ? Math.max(110, ...validRatios) : 110; const annotationYTop = maxYValue + 8; const yAxisUpperBound = annotationYTop + 15; const fig = { data: [ { type: 'bar', name: 'Left', x: plotX, y: plotYLeft, marker: { color: leftColorRgba }, text: leftTextsAbsolute, textposition: 'inside', insidetextanchor: 'middle', textfont: { color: 'white', size: Math.round(14 * globalScaleFactor) }, hoverinfo: 'x+name', hovertemplate: 'Left: %{y:.0f}%<extra></extra>' }, { type: 'bar', name: 'Right', x: plotX, y: plotYRight, marker: { color: rightColorRgba }, text: rightTextsAbsolute, textposition: 'inside', insidetextanchor: 'middle', textfont: { color: 'white', size: Math.round(14 * globalScaleFactor) }, hoverinfo: 'x+name', hovertemplate: 'Right: %{y:.0f}%<extra></extra>' } ], layout: { height: 200, barmode: 'group', font: { color: darkGrayColor, family: 'Avenir, sans-serif', size: Math.round(14 * globalScaleFactor) }, yaxis: { title: "Asymmetry (%)", titlefont: { size: Math.round(14 * globalScaleFactor)}, range: [18, yAxisUpperBound], tickmode: 'array', tickvals: [50, 90, 100], showgrid: false, zeroline: false, }, xaxis: { showgrid: false, zeroline: false, showline: false, tickfont: { size: Math.round(12 * globalScaleFactor)}, automargin: true, fixedrange: true }, paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)', legend: { orientation: "h", yanchor: "bottom", y: 1.05, xanchor: "center", x: 0.5, font: {size: Math.round(12*globalScaleFactor)} }, margin: { l: 45, r: 20, b: 40, t: 35, pad: 5 }, shapes: [ { type: "line", xref: "paper", x0: 0, x1: 1, yref: "y", y0: 90, y1: 90, line: { color: thresholdLineColor, width: 1, dash: "dash" }, layer: "below" }, ], annotations: [] } }; let allGreen = true; for (let i = 0; i < plotX.length; i++) { const metricName = plotX[i]; const injuredRatio = injuredSide === 'Right' ? plotYRight[i] : plotYLeft[i]; if (!isFinite(injuredRatio)) { fig.layout.annotations.push({ x: metricName, y: annotationYTop, text: "N/A", showarrow: false, font: { color: 'grey', size: Math.round(20 * globalScaleFactor) }, xanchor: 'center', yanchor: 'bottom' }); allGreen = false; } else { const percentageDiff = injuredRatio - 100; let color; if (percentageDiff >= -10) { color = 'rgb(42, 157, 143)'; } else if (percentageDiff >= -15) { color = 'rgb(238, 155, 0)'; } else if (percentageDiff >= -20) { color = 'rgb(232, 93, 4)'; } else { color = 'rgb(174, 32, 18)'; } if (percentageDiff < -10) { allGreen = false; } fig.layout.annotations.push({ x: metricName, y: annotationYTop, text: `${percentageDiff.toFixed(0)}%`, showarrow: false, font: { color: color, size: Math.round(20 * globalScaleFactor) }, xanchor: 'center', yanchor: 'bottom' }); } } return [fig, allGreen];}

function mapNkgToPercentile(nkgValue, positionLabel) { const thresholds = normativeThresholds[positionLabel]; if (!thresholds || typeof nkgValue !== 'number' || !isFinite(nkgValue)) return 0; const pMap = [ { v: 0, p: 0 }, { v: thresholds.poor_max, p: percentileZones.poor }, { v: thresholds.average_mid, p: percentileMidpoint }, { v: thresholds.good_min, p: percentileZones.average }, { v: thresholds.excellent_min, p: percentileZones.good }, { v: thresholds.excellent_min * 1.25, p: percentileZones.excellent } ]; pMap.sort((a, b) => a.v - b.v); const minVal = pMap[0].v; const maxVal = pMap[pMap.length - 1].v; const clampedValue = Math.max(minVal, Math.min(nkgValue, maxVal)); let lowerPoint = pMap[0]; let upperPoint = pMap[pMap.length - 1]; for (let i = 0; i < pMap.length - 1; i++) { if (clampedValue >= pMap[i].v && clampedValue <= pMap[i + 1].v) { lowerPoint = pMap[i]; upperPoint = pMap[i + 1]; break; } } if (clampedValue === upperPoint.v) { return upperPoint.p; } if (clampedValue === lowerPoint.v) { return lowerPoint.p; } let percentile = lowerPoint.p; const valueRange = upperPoint.v - lowerPoint.v; const percentileRange = upperPoint.p - lowerPoint.p; if (valueRange > 0) { percentile += ((clampedValue - lowerPoint.v) / valueRange) * percentileRange; } return Math.max(0, Math.min(percentile, 100)); }

function createNormativeComparisonChart(positionData, bodyweight, positionLabel) { const bwVal = parseFloat(bodyweight); if (isNaN(bwVal) || bwVal <= 0 || !positionData) return {}; const leftNkg = positionData.left.max_force / bwVal; const rightNkg = positionData.right.max_force / bwVal; const thresholds = normativeThresholds[positionLabel]; if (!thresholds) return {}; const leftPercentile = mapNkgToPercentile(leftNkg, positionLabel); const rightPercentile = mapNkgToPercentile(rightNkg, positionLabel); const baseCurveX = []; const baseCurveY = []; const mean = 55; const stdDev = 22; const amplitude = 0.9; for (let i = 0; i <= 100; i += 0.5) { baseCurveX.push(i); const y = amplitude * Math.exp(-Math.pow(i - mean, 2) / (2 * Math.pow(stdDev, 2))); baseCurveY.push(y); } const zoneBoundaries = [0, percentileZones.poor, percentileZones.average, percentileZones.good, percentileZones.excellent]; const traces = []; const zoneColorsList = [normZoneColors.poor, normZoneColors.average, normZoneColors.good, normZoneColors.excellent]; for (let i = 0; i < zoneBoundaries.length - 1; i++) { const x0 = zoneBoundaries[i]; const x1 = zoneBoundaries[i+1]; const zoneFillColor = zoneColorsList[i]; const segmentX = [x0]; const segmentY = [0]; for(let j=0; j < baseCurveX.length; j++) { if (baseCurveX[j] >= x0 && baseCurveX[j] <= x1) { segmentX.push(baseCurveX[j]); segmentY.push(baseCurveY[j]); } } segmentX.push(x1); segmentY.push(0); traces.push({ x: segmentX, y: segmentY, type: 'scatter', mode: 'lines', line: { width: 0 }, fill: 'tozeroy', fillcolor: zoneFillColor, hoverinfo: 'none', showlegend: false }); } traces.push({ x: baseCurveX, y: baseCurveY, type: 'scatter', mode: 'lines', line: { color: '#ffffff', width: 1.5, shape: 'spline' }, hoverinfo: 'none', showlegend: false }); const layout = { height: 200, margin: { t: 35, b: 65, l: 30, r: 30 }, paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)', xaxis: { range: [0, 100], showgrid: false, zeroline: false, showticklabels: false }, yaxis: { range: [0, 1.1], showgrid: false, zeroline: false, showticklabels: false }, shapes: [], annotations: [], font: { family: 'Avenir, sans-serif', size: Math.round(11 * globalScaleFactor) }, showlegend: false }; const nkgAnnotationY = -0.08; const nkgAnnotationFont = { family: 'Avenir, sans-serif', size: Math.round(10 * globalScaleFactor), color: getComputedStyle(document.documentElement).getPropertyValue('--app-primary-color').trim() }; layout.annotations.push({ xref: 'x', yref: 'paper', x: percentileZones.poor, y: nkgAnnotationY, text: `<span class="norm-value">${thresholds.poor_max.toFixed(2)}</span>`, showarrow: false, xanchor: 'center', yanchor: 'top', font: nkgAnnotationFont }); layout.annotations.push({ xref: 'x', yref: 'paper', x: percentileZones.average, y: nkgAnnotationY, text: `<span class="norm-value">${thresholds.good_min.toFixed(2)}</span>`, showarrow: false, xanchor: 'center', yanchor: 'top', font: nkgAnnotationFont }); layout.annotations.push({ xref: 'x', yref: 'paper', x: percentileZones.good, y: nkgAnnotationY, text: `<span class="norm-value">${thresholds.excellent_min.toFixed(2)}</span>`, showarrow: false, xanchor: 'center', yanchor: 'top', font: nkgAnnotationFont }); layout.shapes.push({ type: 'line', xref: 'x', yref: 'paper', x0: percentileMidpoint, x1: percentileMidpoint, y0: 0, y1: 1, line: { color: getComputedStyle(document.documentElement).getPropertyValue('--medium-gray').trim(), width: 1.5, dash: 'dot' }, layer: 'below' }); layout.annotations.push({ xref: 'x', yref: 'paper', x: percentileMidpoint, y: nkgAnnotationY, text: `<span class="value-display">${thresholds.average_mid.toFixed(2)}</span>`, showarrow: false, xanchor: 'center', yanchor: 'top', align: 'center', font: { family: 'Avenir, sans-serif', size: Math.round(10 * globalScaleFactor), color: getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim() } }); const labelYPosition = 1.08; const labelFont = { family: 'Avenir, sans-serif', size: Math.round(11 * globalScaleFactor), color: getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim() }; layout.annotations.push({ xref: 'x', yref: 'paper', x: zoneBoundaries[0] + (zoneBoundaries[1] - zoneBoundaries[0])/2, y: labelYPosition, text: `<span class="norm-label">${normativeLabels.poor}</span>`, showarrow: false, xanchor: 'center', yanchor: 'bottom', font: labelFont }); layout.annotations.push({ xref: 'x', yref: 'paper', x: zoneBoundaries[1] + (zoneBoundaries[2] - zoneBoundaries[1])/2, y: labelYPosition, text: `<span class="norm-label">${normativeLabels.average}</span>`, showarrow: false, xanchor: 'center', yanchor: 'bottom', font: labelFont }); layout.annotations.push({ xref: 'x', yref: 'paper', x: zoneBoundaries[2] + (zoneBoundaries[3] - zoneBoundaries[2])/2, y: labelYPosition, text: `<span class="norm-label">${normativeLabels.good}</span>`, showarrow: false, xanchor: 'center', yanchor: 'bottom', font: labelFont }); layout.annotations.push({ xref: 'x', yref: 'paper', x: zoneBoundaries[3] + (zoneBoundaries[4] - zoneBoundaries[3])/2, y: labelYPosition, text: `<span class="norm-label">${normativeLabels.excellent}</span>`, showarrow: false, xanchor: 'center', yanchor: 'bottom', font: labelFont }); const leftColor = getComputedStyle(document.documentElement).getPropertyValue('--left-line-color').trim(); const rightColor = getComputedStyle(document.documentElement).getPropertyValue('--right-line-color').trim(); layout.shapes.push({ type: 'line', xref: 'x', yref: 'paper', x0: leftPercentile, x1: leftPercentile, y0: 0.05, y1: 0.95, line: { color: leftColor, width: 2, dash: 'dash' } }); layout.annotations.push({ xref: 'x', yref: 'paper', x: leftPercentile, y: 0.90, text: 'L', showarrow: true, ax: 0, ay: -15, arrowhead: 0, arrowwidth: 1, arrowcolor: leftColor, font: {color: leftColor, size: Math.round(14 * globalScaleFactor)} }); layout.shapes.push({ type: 'line', xref: 'x', yref: 'paper', x0: rightPercentile, x1: rightPercentile, y0: 0.05, y1: 0.95, line: { color: rightColor, width: 2, dash: 'dash' } }); layout.annotations.push({ xref: 'x', yref: 'paper', x: rightPercentile, y: 0.90, text: 'R', showarrow: true, ax: 0, ay: -15, arrowhead: 0, arrowwidth: 1, arrowcolor: rightColor, font: {color: rightColor, size: Math.round(14 * globalScaleFactor)} }); const combinedNkgText = `<span class='nkg-combined-text'>Left: ${leftNkg.toFixed(2)} | Right: ${rightNkg.toFixed(2)} (N/kg)</span>`; layout.annotations.push({ xref: 'paper', yref: 'paper', x: 0.5, y: -0.25, text: combinedNkgText, showarrow: false, xanchor: 'center', yanchor: 'top', align: 'center', font: { size: Math.round(12 * globalScaleFactor), color: getComputedStyle(document.documentElement).getPropertyValue('--dark-gray').trim() } }); return { data: traces, layout };}

async function updateGraphsAndTable() {
    const injuredSide = patientData.injuredSide;
    const bodyweightValue = patientData.bodyweight;
    const bwVal = parseFloat(bodyweightValue);
    const bodyweightValid = !isNaN(bwVal) && bwVal > 0;
    
    normativeChartDivs.forEach(divId => {
        const container = document.getElementById(divId)?.closest('.graph-column');
        if (container) {
            container.style.display = bodyweightValid ? 'flex' : 'none';
        }
    });

    const plotPromises = [];

    ['I', 'Y', 'T'].forEach((pos, i) => {
        const asymmetryChartDivId = asymmetryChartDivs[i];
        const normativeChartDivId = normativeChartDivs[i];
        const positionData = processInputAndCalculate(pos);

        if (positionData) {
            try {
                const [fig, allGreen] = createAsymmetryChart(positionData, injuredSide, pos);
                plotPromises.push(Plotly.react(asymmetryChartDivId, fig.data, fig.layout, plotlyConfig));
            } catch (error) { console.error(`Error creating asymmetry chart for ${pos}:`, error); }
        }
        if (bodyweightValid && positionData) {
            try {
                const config = createNormativeComparisonChart(positionData, bodyweightValue, pos);
                plotPromises.push(Plotly.react(normativeChartDivId, config.data, config.layout, plotlyConfig));
            } catch (error) { console.error(`Error creating normative chart for ${pos}:`, error); }
        }
    });

    // Wait for all Plotly graphs to be rendered before printing
    await Promise.all(plotPromises);
}


// --- Initializer ---
document.addEventListener('DOMContentLoaded', async () => {
    loadAndPopulateData();
    
    const hasData = screeningData && Object.keys(screeningData).length > 0;

    await updateGraphsAndTable();
    
    if (hasData) {
        // Use a timeout to ensure rendering is complete before print dialog opens
        setTimeout(() => window.print(), 500);
    }
});
</script>
</body>
</html>

